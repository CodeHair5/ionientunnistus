<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Koeputket - Saostuminen</title>
    <style>
        body { margin: 0; background-color: #f0f0f0; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
            display: flex;
            align-items: center;
        }
        label { margin-right: 5px; }
        button { margin-left: 10px; }
    </style>
</head>
<body>
    <!-- Valikko ja nappi -->
    <div id="controls">
        <label for="reagent-select">Valitse reagenssi:</label>
        <select id="reagent-select">
            <option value="ammonia">Ammoniakki</option>
            <option value="naoh">Natriumhydroksidi</option>
            <option value="ki">Kaliumjodidi</option>
        </select>
        <button id="reset-button">Aloita alusta</button>
    </div>

    <!-- Import map for Three.js and its addons -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- Main application script -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        // 1. Basic Setup
        const scene = new THREE.Scene();
        const clock = new THREE.Clock();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 9);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1.5, 0);
         
        // 2. Lighting
        const rgbeLoader = new RGBELoader();
        rgbeLoader.load('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_03_1k.hdr', (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            scene.environment = texture;
            scene.background = new THREE.Color(0xf0f0f0);
        });

        // 3. Materials
        const glassMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, metalness: 0, roughness: 0.05, ior: 1.5, transmission: 1.0,
            thickness: 0.1, transparent: true, side: THREE.DoubleSide, depthWrite: false
        });
        
        const vertexShader = `
            uniform float u_time;
            uniform float u_ripple_start_time;
            uniform float u_ripple_active;
            
            void main() {
                vec3 pos = position;
                if (u_ripple_active > 0.5) {
                    float time_since_ripple = u_time - u_ripple_start_time;
                    if (time_since_ripple > 0.0 && time_since_ripple < 2.5) {
                        float dist = distance(pos.xz, vec2(0.0, 0.0));
                        float ripple_wave = sin(dist * 25.0 - time_since_ripple * 10.0);
                        
                        float damping = 1.0 - smoothstep(0.0, 2.5, time_since_ripple);
                        damping *= smoothstep(0.4, 0.0, dist);

                        pos.y += ripple_wave * 0.08 * damping;
                    }
                }
                gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(pos, 1.0);
            }
        `;

        const fragmentShader = `
            uniform vec3 u_color;
            void main() {
                gl_FragColor = vec4(u_color, 0.75);
            }
        `;

        function createLiquidShaderMaterial(color) {
            return new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: {
                    u_time: { value: 0.0 },
                    u_color: { value: new THREE.Color(color) },
                    u_ripple_start_time: { value: -1000.0 },
                    u_ripple_active: { value: 0.0 },
                },
                transparent: true,
                side: THREE.DoubleSide,
            });
        }

        const copperSulfateMaterial = createLiquidShaderMaterial(0x6495ED);
        const ironIISulfateMaterial = createLiquidShaderMaterial(0x98FB98);
        const leadNitrateMaterial = createLiquidShaderMaterial(0xffffff);
        const ironIIISulfateMaterial = createLiquidShaderMaterial(0xD2B48C);
        const copperAmmoniumMaterial = createLiquidShaderMaterial(0x483D8B);
        
        const createPrecipitateMaterial = (color) => new THREE.MeshPhysicalMaterial({ color, roughness: 0.9, transparent: true, opacity: 1.0 });
        const copperHydroxideMaterial = createPrecipitateMaterial(0x40E0D0);
        const ironIIHydroxideMaterial = createPrecipitateMaterial(0x556B2F);
        const leadHydroxideMaterial = createPrecipitateMaterial(0xffffff);
        const leadIodideMaterial = createPrecipitateMaterial(0xFFD700);
        const ironIIIHydroxideMaterial = createPrecipitateMaterial(0x8B4513);

        // 4. Global variables
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const clickableObjects = [];
        let drops = [];
        let splashParticles = [];
        let sinkingParticles = [];
        let selectedReagent = 'ammonia';
        document.getElementById('reagent-select').addEventListener('change', (e) => { selectedReagent = e.target.value; });
        document.getElementById('reset-button').addEventListener('click', resetSimulation);

        // 5. Helper function to create a test tube
        function createTestTube(position, liquidMaterial, liquidLevel, id) {
            const group = new THREE.Group();
            const radius = 0.5;
            const tubeHeight = 3.0;
            const wallThickness = 0.05;

            const bottomGeometry = new THREE.SphereGeometry(radius, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            bottomGeometry.rotateX(Math.PI);
            const tubeGeometry = new THREE.CylinderGeometry(radius, radius, tubeHeight, 32, 1, true);
            tubeGeometry.translate(0, tubeHeight / 2, 0);
            const mergedGlassGeom = BufferGeometryUtils.mergeGeometries([bottomGeometry, tubeGeometry]);
            const glassMesh = new THREE.Mesh(mergedGlassGeom, glassMaterial);
            glassMesh.renderOrder = 3;
            group.add(glassMesh);
             
            let liquidMesh;
            if (liquidMaterial) {
                const liquidRadius = radius - wallThickness;
                const liquidTubeHeight = tubeHeight * liquidLevel;
                const liquidGeom = createLiquidGeometry(liquidRadius, liquidTubeHeight, 0);
                
                const material = liquidMaterial.clone();
                liquidMesh = new THREE.Mesh(liquidGeom, material);
                liquidMesh.renderOrder = 2;
                group.add(liquidMesh);
            }
             
            group.position.copy(position);
            scene.add(group);

            glassMesh.userData = { 
                id: id, group: group, liquidMesh: liquidMesh, dropCount: 0, 
                originalMaterial: liquidMaterial.clone(),
                originalLiquidHeight: tubeHeight * liquidLevel,
                precipitateMesh: null,
                precipitateHeight: 0,
                isRippleActive: false,
                reactionPending: false,
                reactionComplete: false // Uusi tila reaktion estämiseksi
            };
            clickableObjects.push(glassMesh);
        }

        function createLiquidGeometry(radius, height, bottomOffset) {
            if (height <= 0.001) return new THREE.BufferGeometry();
            const bottomGeom = new THREE.SphereGeometry(radius, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            bottomGeom.rotateX(Math.PI);
            const tubeGeom = new THREE.CylinderGeometry(radius, radius, height, 32, 32);
            tubeGeom.translate(0, height / 2, 0);
            const mergedGeom = BufferGeometryUtils.mergeGeometries([bottomGeom, tubeGeom]);
            mergedGeom.translate(0, bottomOffset, 0);
            return mergedGeom;
        }

        // 6. Create initial tubes
        const tubeSpacing = 2.0;
        createTestTube(new THREE.Vector3(-tubeSpacing * 1.5, 1.5, 0), copperSulfateMaterial, 0.25, 'copperSulfate');
        createTestTube(new THREE.Vector3(-tubeSpacing * 0.5, 1.5, 0), ironIISulfateMaterial, 0.25, 'ironIISulfate');
        createTestTube(new THREE.Vector3(tubeSpacing * 0.5, 1.5, 0), leadNitrateMaterial, 0.25, 'leadNitrate');
        createTestTube(new THREE.Vector3(tubeSpacing * 1.5, 1.5, 0), ironIIISulfateMaterial, 0.25, 'ironIIISulfate');

        // 7. Interactivity & Reaction Logic
        function addDrop(tubeData) {
            if (tubeData.reactionComplete) return; // Estetään uudet tipat, jos reaktio on valmis

            const dropGeometry = new THREE.SphereGeometry(0.1, 16, 8);
            const drop = new THREE.Mesh(dropGeometry, new THREE.MeshPhysicalMaterial({color: 0xffffff, transmission: 0.8, transparent: true, roughness: 0.1}));
            const tubeTopY = tubeData.group.position.y + 3.0;
            const liquidSurfaceY = tubeData.group.position.y + tubeData.originalLiquidHeight;
            
            drop.position.set(tubeData.group.position.x, tubeTopY + 0.5, tubeData.group.position.z);
            drop.userData = { targetY: liquidSurfaceY, tubeData: tubeData };
            drops.push(drop);
            scene.add(drop);
        }
        
        function createSplash(position, color) {
            const splashMaterial = new THREE.PointsMaterial({
                color: color, size: 0.05, transparent: true, opacity: 0.8, depthWrite: false
            });
            const splashGeometry = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 50; i++) { vertices.push(0, 0, 0); }
            splashGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const splash = new THREE.Points(splashGeometry, splashMaterial);
            splash.position.copy(position);
            splash.userData.life = 1.0; 
            splash.userData.velocities = [];
            for (let i = 0; i < 50; i++) {
                splash.userData.velocities.push(
                    (Math.random() - 0.5) * 0.5, (Math.random()) * 0.5, (Math.random() - 0.5) * 0.5
                );
            }
            splashParticles.push(splash);
            scene.add(splash);
        }

        function createSinkingParticles(tubeData, material, count) {
            for (let i = 0; i < count; i++) {
                const particleGeom = new THREE.SphereGeometry(0.02, 6, 6);
                const particle = new THREE.Mesh(particleGeom, material);
                const surfaceY = tubeData.group.position.y + tubeData.originalLiquidHeight;
                
                particle.position.set(
                    tubeData.group.position.x + (Math.random() - 0.5) * 0.6,
                    surfaceY - Math.random() * 0.2,
                    tubeData.group.position.z + (Math.random() - 0.5) * 0.6
                );
                particle.userData.velocityY = (Math.random() - 0.8) * 0.005;
                particle.userData.tubeData = tubeData;
                sinkingParticles.push(particle);
                scene.add(particle);
            }
        }

        function triggerReaction(tubeData) {
            tubeData.dropCount++;
            tubeData.isRippleActive = true;
            tubeData.reactionPending = true;
            
            if (tubeData.liquidMesh && tubeData.liquidMesh.material.uniforms) {
                tubeData.liquidMesh.material.uniforms.u_ripple_active.value = 1.0;
                tubeData.liquidMesh.material.uniforms.u_ripple_start_time.value = clock.getElapsedTime();
            }
            
            handleSinkingParticles(tubeData);
        }
        
        function handleSinkingParticles(tubeData) {
            let precipitateMaterial = getPrecipitateMaterial(tubeData);
            
            if (precipitateMaterial) {
                const surfacePosition = new THREE.Vector3(
                    tubeData.group.position.x, tubeData.group.position.y + tubeData.originalLiquidHeight, tubeData.group.position.z
                );
                createSplash(surfacePosition, precipitateMaterial.color);
                createSinkingParticles(tubeData, precipitateMaterial.clone(), 15);
            }
        }

        function startPrecipitation(tubeData) {
            tubeData.reactionPending = false;
            let precipitateMaterial = getPrecipitateMaterial(tubeData);

            // --- KORJAUS: Ammoniakkikompleksin muodostus ---
            if (tubeData.id === 'copperSulfate' && selectedReagent === 'ammonia' && tubeData.dropCount > 5) { // Vaatii enemmän kuin yhden tipan
                if (tubeData.precipitateMesh) {
                    tubeData.group.remove(tubeData.precipitateMesh);
                    tubeData.precipitateMesh.geometry.dispose();
                    tubeData.precipitateMesh = null;
                }
                tubeData.precipitateHeight = 0;
                const liquidRadius = 0.5 - 0.05;
                const newLiquidGeom = createLiquidGeometry(liquidRadius, tubeData.originalLiquidHeight, 0);
                tubeData.liquidMesh.geometry.dispose();
                tubeData.liquidMesh.geometry = newLiquidGeom;
                
                const oldUniforms = tubeData.liquidMesh.material.uniforms;
                tubeData.liquidMesh.material = copperAmmoniumMaterial.clone();
                tubeData.liquidMesh.material.uniforms.u_ripple_start_time = oldUniforms.u_ripple_start_time;
                tubeData.liquidMesh.material.uniforms.u_ripple_active = oldUniforms.u_ripple_active;
                tubeData.reactionComplete = true; // Estetään jatkoreaktiot
                return;
            }

            if (precipitateMaterial) {
                if (!tubeData.precipitateMesh) {
                    const precipitateGeom = createLiquidGeometry(0.45, 0.001, 0);
                    const precipitateMesh = new THREE.Mesh(precipitateGeom, precipitateMaterial);
                    precipitateMesh.renderOrder = 1;
                    tubeData.group.add(precipitateMesh);
                    tubeData.precipitateMesh = precipitateMesh;
                }
                if (tubeData.id === 'leadNitrate' && selectedReagent === 'ki') {
                    tubeData.precipitateMesh.material = leadIodideMaterial;
                }
            }
        }
        
        function getPrecipitateMaterial(tubeData) {
            const id = tubeData.id;
            if (id === 'copperSulfate' && (selectedReagent === 'naoh' || selectedReagent === 'ammonia')) {
                return copperHydroxideMaterial;
            } else if (id === 'ironIISulfate' && (selectedReagent === 'naoh' || selectedReagent === 'ammonia')) {
                return ironIIHydroxideMaterial;
            } else if (id === 'leadNitrate' && (selectedReagent === 'naoh' || selectedReagent === 'ammonia')) {
                return leadHydroxideMaterial;
            } else if (id === 'leadNitrate' && selectedReagent === 'ki') {
                return leadIodideMaterial;
            } else if (id === 'ironIIISulfate' && (selectedReagent === 'naoh' || selectedReagent === 'ammonia')) {
                return ironIIIHydroxideMaterial;
            }
            return null;
        }


        function resetSimulation() {
            drops.forEach(d => scene.remove(d));
            splashParticles.forEach(p => scene.remove(p));
            sinkingParticles.forEach(p => scene.remove(p));
            drops = []; splashParticles = []; sinkingParticles = [];

            clickableObjects.forEach(glassMesh => {
                const tubeData = glassMesh.userData;
                tubeData.dropCount = 0;
                tubeData.precipitateHeight = 0;
                tubeData.isRippleActive = false;
                tubeData.reactionPending = false;
                tubeData.reactionComplete = false;
                tubeData.liquidMesh.material = tubeData.originalMaterial.clone();
                if (tubeData.precipitateMesh) {
                    tubeData.group.remove(tubeData.precipitateMesh);
                    tubeData.precipitateMesh.geometry.dispose();
                    tubeData.precipitateMesh = null;
                }
                const liquidRadius = 0.5 - 0.05;
                const newLiquidGeom = createLiquidGeometry(liquidRadius, tubeData.originalLiquidHeight, 0);
                tubeData.liquidMesh.geometry.dispose();
                tubeData.liquidMesh.geometry = newLiquidGeom;
            });
        }

        window.addEventListener('click', (event) => {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(clickableObjects);
            if (intersects.length > 0) { addDrop(intersects[0].object.userData); }
        });

        function fadeLiquidColor(tubeData) {
            const color = tubeData.liquidMesh.material.uniforms.u_color.value;
            const hsl = {};
            color.getHSL(hsl);
            hsl.s = Math.max(0.1, hsl.s * 0.98); 
            hsl.l = Math.min(1.0, hsl.l + 0.002); 
            color.setHSL(hsl.h, hsl.s, hsl.l);
        }

        // 8. Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            const delta = clock.getDelta();

            clickableObjects.forEach(obj => {
                const tubeData = obj.userData;
                if(tubeData.isRippleActive && tubeData.liquidMesh && tubeData.liquidMesh.material.uniforms) {
                    const uniforms = tubeData.liquidMesh.material.uniforms;
                    uniforms.u_time.value = elapsedTime;
                    const rippleStartTime = uniforms.u_ripple_start_time.value;
                    const rippleDuration = 2.5;
                    
                    if(elapsedTime - rippleStartTime > rippleDuration) {
                        uniforms.u_ripple_active.value = 0.0;
                        tubeData.isRippleActive = false;
                        if (tubeData.reactionPending) {
                            startPrecipitation(tubeData);
                        }
                    }
                }
            });

            for (let i = drops.length - 1; i >= 0; i--) {
                const drop = drops[i];
                drop.position.y -= 0.1;
                if (drop.position.y <= drop.userData.targetY) {
                    triggerReaction(drop.userData.tubeData);
                    scene.remove(drop);
                    drops.splice(i, 1);
                }
            }
            
            for (let i = splashParticles.length - 1; i >= 0; i--) {
                const splash = splashParticles[i];
                splash.userData.life -= delta;
                const positions = splash.geometry.attributes.position;
                for (let j = 0; j < positions.count; j++) {
                    positions.setX(j, positions.getX(j) + splash.userData.velocities[j*3] * delta);
                    positions.setY(j, positions.getY(j) + splash.userData.velocities[j*3+1] * delta);
                    positions.setZ(j, positions.getZ(j) + splash.userData.velocities[j*3+2] * delta);
                }
                positions.needsUpdate = true;
                splash.material.opacity = splash.userData.life;
                if (splash.userData.life <= 0) {
                    scene.remove(splash);
                    splashParticles.splice(i, 1);
                }
            }

            for (let i = sinkingParticles.length - 1; i >= 0; i--) {
                const particle = sinkingParticles[i];
                const tubeData = particle.userData.tubeData;
                const tubeBottomY = tubeData.group.position.y - 0.45;

                particle.userData.velocityY += 0.0001;
                particle.position.y -= particle.userData.velocityY;

                if (particle.position.y <= tubeBottomY + tubeData.precipitateHeight) {
                    if (tubeData.precipitateMesh && (!tubeData.isRippleActive || tubeData.precipitateHeight > 0)) {
                        tubeData.precipitateHeight += 0.005;
                        const maxPrecipitateHeight = tubeData.originalLiquidHeight * 0.8;
                        tubeData.precipitateHeight = Math.min(tubeData.precipitateHeight, maxPrecipitateHeight);

                        const liquidRadius = 0.5 - 0.05;
                        
                        const newPrecipitateGeom = createLiquidGeometry(liquidRadius, tubeData.precipitateHeight, 0);
                        tubeData.precipitateMesh.geometry.dispose();
                        tubeData.precipitateMesh.geometry = newPrecipitateGeom;

                        const newLiquidHeight = tubeData.originalLiquidHeight - tubeData.precipitateHeight;
                        const newLiquidGeom = createLiquidGeometry(liquidRadius, newLiquidHeight, tubeData.precipitateHeight);
                        tubeData.liquidMesh.geometry.dispose();
                        tubeData.liquidMesh.geometry = newLiquidGeom;
                        
                        fadeLiquidColor(tubeData);
                    }
                    scene.remove(particle);
                    sinkingParticles.splice(i, 1);
                }
            }
            
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
