<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js - Koeputket - Parannellut Reaktiot</title>
    <style>
        body { margin: 0; background-color: #333; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; }
        #controls { position: absolute; top: 10px; left: 10px; padding: 10px; background: rgba(255, 255, 255, 0.8); border-radius: 5px; display: flex; align-items: center; visibility: hidden; }
        label { margin-right: 5px; }
        button { margin-left: 10px; }
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7); display: flex;
            justify-content: center; align-items: center; color: white;
        }
        #start-button { font-size: 2em; padding: 20px 40px; cursor: pointer; border: none; border-radius: 10px; }
        #start-button:disabled { cursor: wait; background-color: #555; color: #aaa; }
        
        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border-radius: 8px;
            text-align: center;
            visibility: hidden; /* Piilotettu oletuksena */
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>
    <div id="controls">
        <label for="reagent-select">Valitse reagenssi:</label>
        <select id="reagent-select">
            <option value="ammonia">Ammoniakki</option>
            <option value="naoh">Natriumhydroksidi</option>
            <option value="ki">Kaliumjodidi</option>
        </select>
        <button id="reset-button">Aloita alusta</button>
    </div>
    
    <div id="start-screen">
        <button id="start-button" disabled>Ladataan...</button>
    </div>

    <div id="instructions">
        Mitä ioneja koeputket sisältävät?<br>Valitse tunnistusreagenssi ja klikkaa koeputkea.
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        // 1. Perusasetukset
        const scene = new THREE.Scene();
        const clock = new THREE.Clock();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2.5, 12);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.localClippingEnabled = true;
        document.body.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1.5, 0);

        const startButton = document.getElementById('start-button');
        new RGBELoader().load('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_03_1k.hdr', (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            scene.environment = texture;
            preloadShaders();
            startButton.disabled = false;
            startButton.textContent = 'Aloita simulaatio';
        });
        
        const glassMaterial = new THREE.MeshPhysicalMaterial({ color: 0xffffff, metalness: 0.1, roughness: 0.05, ior: 1.5, transmission: 1.0, transparent: true });
        const createPrecipitateMaterial = (color, clippingPlane) => new THREE.MeshPhysicalMaterial({
            color, roughness: 0.8, side: THREE.DoubleSide, clippingPlanes: [clippingPlane]
        });

        const clickableTubes = [];
        let activeDrops = [];
        let sinkingParticles = [];
        let selectedReagent = 'ammonia';
        const particlePool = [];
        const MAX_PARTICLES = 200; 

        // UUSI: Globaali reaktiomäärittely
        const REACTIONS = {
            copperSulfate: {
                naoh: { type: 'precipitate', color: 0x55E0C0 }, // Vaaleansininen
                ammonia: { type: 'precipitate', color: 0x55E0C0 }, // Vaaleansininen (liukenee)
                ki: { type: 'solution', color: 0x8B4513 } // Ruskea feidaus (I2)
            },
            ironIISulfate: {
                naoh: { type: 'precipitate', color: 0x8FBC8F }, // Likaisenvihreä
                ammonia: { type: 'precipitate', color: 0x8FBC8F } // Likaisenvihreä
            },
            ironIIISulfate: {
                naoh: { type: 'precipitate', color: 0xA0522D }, // Punaruskea
                ammonia: { type: 'precipitate', color: 0xA0522D }, // Punaruskea
                ki: { type: 'solution', color: 0x8B4513 } // Tummanruskea (I2)
            },
            leadNitrate: {
                naoh: { type: 'precipitate', color: 0xf0f0f0 }, // Valkoinen (liukenee)
                ammonia: { type: 'precipitate', color: 0xf0f0f0 }, // Valkoinen
                ki: { type: 'precipitate', color: 0xFFEB00 } // Kirkkaankeltainen
            },
            silverNitrate: {
                naoh: { type: 'precipitate', color: 0x8B4513 }, // Ruskea (Ag2O)
                ammonia: { type: 'precipitate', color: 0x8B4513 }, // Ruskea (liukenee)
                ki: { type: 'precipitate', color: 0xF5DEB3 } // Haaleankeltainen (AgI)
            }
        };

        function createTubeGeometry(radius, height, openEnded = false) {
            const cylinderHeight = height - radius;
            if (cylinderHeight < 0) return new THREE.BufferGeometry();
            const tubeCylinder = new THREE.CylinderGeometry(radius, radius, cylinderHeight, 32, 1, openEnded);
            tubeCylinder.translate(0, cylinderHeight / 2, 0);
            const bottomSphere = new THREE.SphereGeometry(radius, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            bottomSphere.rotateX(Math.PI);
            const merged = BufferGeometryUtils.mergeGeometries([bottomSphere, tubeCylinder]);
            merged.translate(0, radius, 0);
            return merged;
        }
        
        function createTestTube(position, id, liquidColor) {
            const group = new THREE.Group();
            group.position.copy(position);
            
            const TUBE_RADIUS = 0.5, TUBE_HEIGHT = 3.0, WALL_THICKNESS = 0.05;
            const LIQUID_HEIGHT = TUBE_HEIGHT * 0.6, LIQUID_RADIUS = TUBE_RADIUS - WALL_THICKNESS;

            const glassGeometry = createTubeGeometry(TUBE_RADIUS, TUBE_HEIGHT, false);
            const glassMesh = new THREE.Mesh(glassGeometry, glassMaterial);
            glassMesh.renderOrder = 4;
            group.add(glassMesh);
            
            const liquidBodyGeom = createTubeGeometry(LIQUID_RADIUS, LIQUID_HEIGHT, true);
            const liquidBodyMat = new THREE.MeshPhysicalMaterial({ 
                color: liquidColor, roughness: 0.1, transmission: 0.9, transparent: true, thickness: 0.2, side: THREE.DoubleSide
            });
            const liquidBodyMesh = new THREE.Mesh(liquidBodyGeom, liquidBodyMat);
            liquidBodyMesh.renderOrder = 3;
            group.add(liquidBodyMesh);

            const liquidSurfaceGeom = new THREE.CircleGeometry(LIQUID_RADIUS, 64);
            liquidSurfaceGeom.rotateX(-Math.PI / 2);
            liquidSurfaceGeom.translate(0, LIQUID_HEIGHT, 0);
            
            const originalMaterial = new THREE.MeshPhysicalMaterial({
                color: liquidColor, roughness: 0.1, transmission: 0.9, transparent: true, thickness: 0.2
            });

            const shaderUniforms = {
                uTime: { value: 0 },
                uDropTime: { value: -1000 },
                uDropCenter: { value: new THREE.Vector2(0.5, 0.5) },
            };

            originalMaterial.onBeforeCompile = (shader) => {
                shader.uniforms.uTime = shaderUniforms.uTime;
                shader.uniforms.uDropTime = shaderUniforms.uDropTime;
                shader.uniforms.uDropCenter = shaderUniforms.uDropCenter;
                shader.vertexShader = `
                    uniform float uTime; uniform float uDropTime; uniform vec2 uDropCenter;
                    float getWaveHeight(vec2 uvPos) {
                        float timeSinceDrop = uTime - uDropTime;
                        if (timeSinceDrop < 0.0 || timeSinceDrop > 3.0) return 0.0;
                        vec2 centeredUv = uvPos - vec2(0.5); float dist = length(centeredUv) * 2.0;
                        float speed = 1.2; float frequency = 20.0;
                        float waveFront = timeSinceDrop * speed;
                        if (dist > waveFront + 0.1) return 0.0;
                        float decay = 1.0 - timeSinceDrop / 3.0; float amplitude = 0.11 * decay * decay;
                        float wave = sin(dist * frequency - timeSinceDrop * speed * frequency);
                        float pulse = smoothstep(waveFront, waveFront - 1.0, dist);
                        return wave * amplitude * pulse;
                    }
                ` + shader.vertexShader;
                shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', `#include <begin_vertex>\ntransformed.y += getWaveHeight(uv);`);
                shader.vertexShader = shader.vertexShader.replace('#include <beginnormal_vertex>', `#include <beginnormal_vertex>\nfloat gridStep = 0.02;float hU = getWaveHeight(uv + vec2(gridStep, 0.0));float hD = getWaveHeight(uv - vec2(gridStep, 0.0));float hL = getWaveHeight(uv + vec2(0.0, gridStep));float hR = getWaveHeight(uv - vec2(0.0, gridStep));objectNormal = normalize(vec3(hD - hU, gridStep * 2.0, hR - hL));`);
            };

            const liquidSurfaceMesh = new THREE.Mesh(liquidSurfaceGeom, originalMaterial);
            liquidSurfaceMesh.renderOrder = 3;
            liquidSurfaceMesh.userData = { shaderUniforms };
            group.add(liquidSurfaceMesh);

            const precipitateClipPlane = new THREE.Plane(new THREE.Vector3(0, -1, 0), 0);
            const precipitateGeometry = createTubeGeometry(LIQUID_RADIUS, LIQUID_HEIGHT, true);
            const precipitateMesh = new THREE.Mesh(precipitateGeometry, null);
            precipitateMesh.renderOrder = 1; precipitateMesh.visible = false; group.add(precipitateMesh);
            
            const capGeometry = new THREE.CircleGeometry(LIQUID_RADIUS, 32);
            capGeometry.rotateX(-Math.PI / 2);
            const precipitateCapMesh = new THREE.Mesh(capGeometry, null);
            precipitateCapMesh.renderOrder = 2; precipitateCapMesh.visible = false; group.add(precipitateCapMesh);

            glassMesh.userData = { 
                id, group, liquidMesh: liquidBodyMesh, liquidSurface: liquidSurfaceMesh, precipitateMesh, precipitateCapMesh, precipitateClipPlane, dropCount: 0, originalColor: liquidColor, 
                originalLiquidHeight: LIQUID_HEIGHT, precipitateHeight: 0, liquidRadius: LIQUID_RADIUS, 
                reactionComplete: false, isDissolving: false, precipitateTargetHeight: 0, growthPending: false,
                // UUDET TILAT FEIDAUSTA VARTEN
                isFading: false, 
                fadeTargetColor: null 
            };
            clickableTubes.push(glassMesh);
            return group;
        }

        // MUUTOS: Käyttää globaalia REACTIONS-karttaa
        function getReactionResult(tubeId, reagent) {
            return REACTIONS[tubeId]?.[reagent] || null;
        }

        // MUUTOS: Lukee reaktiot globaalista REACTIONS-kartasta
        function preloadShaders() {
            console.log("Pre-compiling shaders...");
            const dummyScene = new THREE.Scene();
            const dummyGeom = new THREE.SphereGeometry(0.01);
            const dummyPlane = new THREE.Plane();
            
            const uniqueColors = new Set();

            for (const tube in REACTIONS) {
                for (const reagent in REACTIONS[tube]) {
                    const result = REACTIONS[tube][reagent];
                    if (result.type === 'precipitate') { // Esiladataan vain sakkojen shaderit
                        uniqueColors.add(result.color);
                    }
                }
            }
            // Lisätään kuparikompleksin väri manuaalisesti
            uniqueColors.add(0x483D8B); 

            uniqueColors.forEach(color => {
                const mat = createPrecipitateMaterial(color, dummyPlane);
                const mesh = new THREE.Mesh(dummyGeom, mat);
                dummyScene.add(mesh);
            });

            renderer.compile(dummyScene, camera);
             console.log("Shaders compiled.");
        }
        
        function initializeSimulation() {
            const tubeDefs = [
                { id: 'copperSulfate', color: 0x6495ED },  // Kupari (sininen)
                { id: 'ironIISulfate', color: 0x98FB98 },  // Rauta II (vaaleanvihreä)
                { id: 'leadNitrate', color: 0xffffff },    // Lyijy (väritön)
                { id: 'ironIIISulfate', color: 0xD2B48C }, // Rauta III (kellertävänruskea)
                { id: 'silverNitrate', color: 0xffffff }   // Hopea (väritön)
            ];
            
            // Sekoitetaan järjestys
            for (let i = tubeDefs.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [tubeDefs[i], tubeDefs[j]] = [tubeDefs[j], tubeDefs[i]];
            }

            tubeDefs.forEach((def, i) => {
                const xPos = (i - (tubeDefs.length - 1) / 2) * 1.8;
                scene.add(createTestTube(new THREE.Vector3(xPos, 0, 0), def.id, def.color));
            });
            const particleGeom = new THREE.SphereGeometry(0.02, 8, 8);
            for (let i = 0; i < MAX_PARTICLES; i++) {
                const particle = new THREE.Mesh(particleGeom, new THREE.MeshBasicMaterial());
                particle.visible = false; scene.add(particle); particlePool.push(particle);
            }
        }

        function resetSimulation() {
            clickableTubes.forEach(glassMesh => {
                const tubeState = glassMesh.userData;
                tubeState.precipitateHeight = 0; tubeState.precipitateTargetHeight = 0;
                tubeState.precipitateClipPlane.constant = 0;
                tubeState.precipitateMesh.visible = false; tubeState.precipitateMesh.material = null;
                tubeState.precipitateCapMesh.visible = false; tubeState.precipitateCapMesh.material = null;
                tubeState.liquidMesh.material.color.set(tubeState.originalColor);
                tubeState.liquidSurface.material.color.set(tubeState.originalColor);
                tubeState.liquidSurface.userData.shaderUniforms.uDropTime.value = -1000;
                tubeState.dropCount = 0; tubeState.reactionComplete = false;
                tubeState.isDissolving = false; tubeState.growthPending = false;
                
                // UUSI: Nollataan feidaus-tilat
                tubeState.isFading = false; 
                tubeState.fadeTargetColor = null;
            });
            sinkingParticles.forEach(p => { p.visible = false; particlePool.push(p); });
            sinkingParticles = [];
            activeDrops.forEach(d => scene.remove(d)); activeDrops = [];
            // Huom: Ei poisteta tai luoda putkia uudelleen, jotta sijainnit eivät vaihdu resetissä
        }

        function addDrop(tubeState) {
            if (tubeState.reactionComplete) return;
            const drop = new THREE.Mesh( new THREE.SphereGeometry(0.1, 16, 8), new THREE.MeshPhysicalMaterial({color: 0xffffff, transmission: 0.8, transparent: true, roughness: 0.1}));
            const liquidSurfaceY = tubeState.group.position.y + tubeState.originalLiquidHeight;
            drop.position.set(tubeState.group.position.x, liquidSurfaceY + 2.0, tubeState.group.position.z);
            drop.userData = { isDrop: true, targetY: liquidSurfaceY, tubeState: tubeState };
            activeDrops.push(drop); scene.add(drop);
        }

        function onDropImpact(tubeState) {
            triggerReaction(tubeState);
            const uniforms = tubeState.liquidSurface.userData.shaderUniforms;
            uniforms.uDropTime.value = clock.getElapsedTime() - 1.1; 
            uniforms.uDropCenter.value.set(0.5 + (Math.random() - 0.5) * 0.3, 0.5 + (Math.random() - 0.5) * 0.3);
        }

        // MUUTOS: Käsittelee erilaisia reaktiotyyppejä
        function triggerReaction(tubeState) {
            if (tubeState.reactionComplete && !tubeState.growthPending) return; // Älä reagoi, jos feidaus kesken tai valmis
            tubeState.dropCount++;
            
            const result = getReactionResult(tubeState.id, selectedReagent);
            
            if (result) {
                if (result.type === 'precipitate') {
                    // Estä uusien partikkelien synty, jos liukeneminen on jo alkanut
                    if (tubeState.isDissolving) return; 
                    
                    tubeState.growthPending = true;
                    for(let i=0; i < 10; i++) activateSinkingParticle(tubeState, result.color);
                } 
                else if (result.type === 'solution') {
                    tubeState.isFading = true;
                    tubeState.fadeTargetColor = new THREE.Color(result.color);
                    tubeState.reactionComplete = true; // Merkitään reaktio valmiiksi (ei enää tippoja)
                }
            }
        }
        
        function activateSinkingParticle(tubeState, color) {
            if (particlePool.length === 0) return;
            const particle = particlePool.pop(); particle.material.color.set(color);
            const surfaceY = tubeState.group.position.y + tubeState.originalLiquidHeight;
            particle.position.set( tubeState.group.position.x + (Math.random() - 0.5) * tubeState.liquidRadius, surfaceY, tubeState.group.position.z + (Math.random() - 0.5) * tubeState.liquidRadius);
            particle.userData.velocityY = 0; particle.userData.acceleration = 0.4 + Math.random() * 0.4;
            particle.userData.tubeState = tubeState; particle.visible = true; sinkingParticles.push(particle);
        }

        const raycaster = new THREE.Raycaster();
        window.addEventListener('click', (event) => {
            const mouse = new THREE.Vector2((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(clickableTubes);
            if (intersects.length > 0) addDrop(intersects[0].object.userData);
        });
        
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();

            for (let i = activeDrops.length - 1; i >= 0; i--) {
                const drop = activeDrops[i];
                drop.position.y -= 8.0 * delta;
                if (drop.position.y <= drop.userData.targetY) {
                    onDropImpact(drop.userData.tubeState);
                    scene.remove(drop); activeDrops.splice(i, 1);
                }
            }

            for (let i = sinkingParticles.length - 1; i >= 0; i--) {
                const particle = sinkingParticles[i]; particle.userData.velocityY += particle.userData.acceleration * delta; particle.position.y -= particle.userData.velocityY * delta;
                const tubeState = particle.userData.tubeState; const precipitateSurface = tubeState.group.position.y + tubeState.precipitateHeight;
                if (particle.position.y <= precipitateSurface) {
                    particle.visible = false; particlePool.push(particle); sinkingParticles.splice(i, 1);
                    
                    if (tubeState.growthPending) {
                        tubeState.growthPending = false;
                        
                        // --- MUUTOS: Laajennettu tarkistamaan kaikki liukenevat reaktiot ---
                        const dropThreshold = 5;
                        const isCopperComplex = (tubeState.id === 'copperSulfate' && selectedReagent === 'ammonia' && tubeState.dropCount > dropThreshold);
                        const isLeadComplex = (tubeState.id === 'leadNitrate' && selectedReagent === 'naoh' && tubeState.dropCount > dropThreshold);
                        const isSilverComplex = (tubeState.id === 'silverNitrate' && selectedReagent === 'ammonia' && tubeState.dropCount > dropThreshold);

                        if (isCopperComplex || isLeadComplex || isSilverComplex) {
                            tubeState.isDissolving = true; 
                            tubeState.precipitateTargetHeight = 0;
                        } else {
                            if (!tubeState.precipitateMesh.material) {
                                const result = getReactionResult(tubeState.id, selectedReagent);
                                if (result && result.type === 'precipitate') {
                                    const precipitateColor = result.color;
                                    tubeState.precipitateMesh.material = createPrecipitateMaterial(precipitateColor, tubeState.precipitateClipPlane);
                                    tubeState.precipitateCapMesh.material = new THREE.MeshPhysicalMaterial({ color: precipitateColor, roughness: 0.8 });
                                    tubeState.precipitateMesh.visible = true;
                                }
                            }
                            if(tubeState.precipitateMesh.material) { // Varmistus, että materiaali on olemassa
                                tubeState.precipitateTargetHeight += 0.3;
                                tubeState.precipitateTargetHeight = Math.min(tubeState.precipitateTargetHeight, tubeState.originalLiquidHeight);
                            }
                        }
                    }
                }
            }
            
            clickableTubes.forEach(glassMesh => {
                const tubeState = glassMesh.userData;
                tubeState.liquidSurface.userData.shaderUniforms.uTime.value = elapsedTime;

                // --- UUSI: LIUOKSEN VÄRIN FEIDAUS ---
                if (tubeState.isFading && tubeState.fadeTargetColor) {
                    const fadeSpeed = 0.05; // Hitaampi, pehmeämpi feidaus
                    tubeState.liquidMesh.material.color.lerp(tubeState.fadeTargetColor, fadeSpeed);
                    tubeState.liquidSurface.material.color.lerp(tubeState.fadeTargetColor, fadeSpeed);
                    
                    // Tarkistetaan, onko väri riittävän lähellä kohdetta (RGB-etäisyys)
                    const current = tubeState.liquidMesh.material.color;
                    const target = tubeState.fadeTargetColor;
                    const dr = current.r - target.r, dg = current.g - target.g, db = current.b - target.b;
                    if ((dr*dr + dg*dg + db*db) < 1e-6) {
                        tubeState.isFading = false;
                        // Asetetaan tarkka loppuväri
                        tubeState.liquidMesh.material.color.copy(target);
                        tubeState.liquidSurface.material.color.copy(target);
                        tubeState.fadeTargetColor = null;
                    }
                }

                // --- SAKAN KASVU/LIUKENEMISANIMAATIO ---
                const needsUpdate = (tubeState.precipitateMesh.visible || tubeState.isDissolving) && Math.abs(tubeState.precipitateHeight - tubeState.precipitateTargetHeight) > 0.001;
                if (needsUpdate) {
                    const direction = Math.sign(tubeState.precipitateTargetHeight - tubeState.precipitateHeight);
                    const speed = (tubeState.isDissolving) ? 0.9 : 0.3;
                    tubeState.precipitateHeight += direction * speed * delta;
                    tubeState.precipitateClipPlane.constant = tubeState.precipitateHeight;
                    tubeState.precipitateCapMesh.position.y = tubeState.precipitateHeight;
                    const R = tubeState.liquidRadius; const h = tubeState.precipitateHeight; let capScale = 1.0;
                    if (h < R) { const currentRadius = Math.sqrt(2 * R * h - h * h); capScale = isNaN(currentRadius) ? 0 : currentRadius / R; }
                    tubeState.precipitateCapMesh.scale.set(capScale, 1.0, capScale);
                    tubeState.precipitateCapMesh.visible = tubeState.precipitateHeight > 0.001;
                    if (direction > 0) {
                        const color = tubeState.liquidMesh.material.color; const hsl = {}; color.getHSL(hsl);
                        hsl.s = Math.max(0.1, hsl.s * 0.99); color.setHSL(hsl.h, hsl.s, hsl.l);
                        tubeState.liquidSurface.material.color.set(color);
                    }
                } 
                // --- MUUTOS: Käsittelee eri kompleksien loppuvärit ---
                else if (tubeState.isDissolving && !needsUpdate) {
                    tubeState.isDissolving = false; tubeState.reactionComplete = true;
                    tubeState.precipitateMesh.visible = false; tubeState.precipitateCapMesh.visible = false;
                    
                    let finalColor;
                    if (tubeState.id === 'copperSulfate' && selectedReagent === 'ammonia') {
                        finalColor = 0x483D8B; // Tummansininen kuparikompleksi
                    } else if ((tubeState.id === 'leadNitrate' && selectedReagent === 'naoh') ||
                               (tubeState.id === 'silverNitrate' && selectedReagent === 'ammonia')) {
                        finalColor = tubeState.originalColor; // Värittömät kompleksit (paluu alkuperäiseen)
                    }

                    if (finalColor !== undefined) {
                        tubeState.liquidMesh.material.color.set(finalColor);
                        tubeState.liquidSurface.material.color.set(finalColor);
                    }
                }
            });

            controls.update();
            renderer.render(scene, camera);
        }
        
        startButton.addEventListener('click', () => {
            const controlsDiv = document.getElementById('controls');
            const instructionsDiv = document.getElementById('instructions');
            document.getElementById('start-screen').style.display = 'none';
            controlsDiv.style.visibility = 'visible';
            
            instructionsDiv.style.visibility = 'visible';
            instructionsDiv.style.opacity = '1';
            setTimeout(() => {
                instructionsDiv.style.opacity = '0';
                setTimeout(() => { instructionsDiv.style.visibility = 'hidden'; }, 500);
            }, 10000);

            initializeSimulation(); 
            animate();
        });
        
        document.getElementById('reagent-select').addEventListener('change', (e) => { selectedReagent = e.target.value; });
        document.getElementById('reset-button').addEventListener('click', resetSimulation);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>